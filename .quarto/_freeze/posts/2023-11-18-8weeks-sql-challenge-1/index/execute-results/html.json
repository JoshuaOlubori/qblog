{
  "hash": "4967950e0ebf943c3f87d308ec6fcb37",
  "result": {
    "markdown": "---\ntitle: \"Danny's Diner\"\nsubtitle: \"In this first part of a series of SQL case studies, I use Postgres SQL to answer a bunch of business questions\"\nauthor: \"Edun Joshua\"\ndate: \"2023-11-18\"\ncategories: [sql]\nimage: \"image.jpg\"\n---\n\n\n\n## Introduction\n\nA restaurant, Danny's Diner, sells 3 foods: sushi, curry and ramen. Danny's Diner is in need of your assistance to help the restaurant stay afloat - the restaurant has captured some very basic data from their few months of operation but have no idea how to use their data to help them run the business.\n\nYou have 3 key datasets for this case study:\n\n-   **sales**\n\n-   **menu**\n\n-   **members**\n\n## Entity Relationship Diagram\n\n![](images/danny_diners_schema.jpg)\n\n### Sales\n\nThe sales table captures all customer_id level purchases with an corresponding order_date and product_id information for when and what menu items were ordered.\n\n### Menu\n\nThe final members table captures the join_date when a customer_id joined the beta version of the Danny's Diner loyalty program.\n\n### Members\n\nThe final members table captures the join_date when a customer_id joined the beta version of the Danny's Diner loyalty program.\n\n| **key concepts**: CTEs, window functions\n\n## Database Connection\n\nFirst, I'll create a connection to my local postgres database thanks to the **RPostgres** package.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# | warning: false\n# Creating a connection to my local postgres database\nlibrary(RPostgres)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'RPostgres' was built under R version 4.3.2\n```\n:::\n\n```{.r .cell-code}\ncon <-\n  dbConnect(Postgres(),\n            dbname = \"danny_diners\",\n            user = \"postgres\",\n            password = my_password)\n```\n:::\n\n\n## Queries\n\nNow let's convert business questions into SQL queries!\n\n### 1. What is the total amount each customer spent at the restaurant?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nselect s.customer_id as customer,\n   sum(m.price) as total_amount\nfrom sales s\n   inner join menu m on s.product_id = m.product_id\ngroup by customer;\n\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 3 records\n\n|customer | total_amount|\n|:--------|------------:|\n|B        |           74|\n|C        |           36|\n|A        |           76|\n\n</div>\n:::\n\n\n### 2. How many days has each customer visited the restaurant?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nselect customer_id,\n   count(\n      distinct extract(\n         day\n         from order_date\n      )\n   ) as no_of_days_visited\nfrom sales\ngroup by customer_id\norder by customer_id;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 3 records\n\n|customer_id | no_of_days_visited|\n|:-----------|------------------:|\n|A           |                  4|\n|B           |                  5|\n|C           |                  2|\n\n</div>\n:::\n\n\nThis SQL query calculates the number of days each customer has visited a restaurant by grouping the sales transactions by customer ID, extracting the day from the order date, counting the distinct days, and ordering the results by customer ID.\n\n### 3. What was the first item from the menu purchased by each customer?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nwith cte as (\n   select customer_id,\n      order_date,\n      row_number() over (\n         partition by customer_id\n         order by order_date\n      ) as order_rank,\n      product_id\n   from sales\n)\nselect c.customer_id,\n   c.order_date,\n   c.order_rank,\n   m.product_name\nfrom cte c\n   natural join menu m\nwhere order_rank = 1;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 3 records\n\n|customer_id |order_date | order_rank|product_name |\n|:-----------|:----------|----------:|:------------|\n|A           |2021-01-01 |          1|sushi        |\n|B           |2021-01-01 |          1|curry        |\n|C           |2021-01-01 |          1|ramen        |\n\n</div>\n:::\n\n\nWithin the CTE, the `row_number()` function is employed to assign a ranking to each order for each customer based on the `order_date`. The ranking starts from 1, indicating the first order for each customer. The main query then selects the customer ID, order date, order rank, and product name from the CTE, joining the `menu` table to retrieve the product name corresponding to the product ID. Finally, it filters the results to include only records with an order rank of 1, effectively selecting the first item purchased for each customer.\n\n### 4. What is the most purchased item on the menu and how many times was it purchased by all customers?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nwith cte as(\n   select product_id,\n      count(product_id)\n   from sales\n   group by product_id\n   order by count(product_id) desc\n   limit 1\n) -- Most purchased item on the menu is the product with the id 3 which is ramen, according to cte\nselect customer_id,\n   count(product_id) as count_of_most_purchased_product\nfrom sales\nwhere product_id in (\n      select product_id\n      from cte\n   )\ngroup by customer_id;\n\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 3 records\n\n|customer_id | count_of_most_purchased_product|\n|:-----------|-------------------------------:|\n|A           |                               3|\n|B           |                               2|\n|C           |                               3|\n\n</div>\n:::\n\n\nThe query utilizes a common table expression (CTE) named `cte` to generate a temporary result set. Within the CTE, the `count()` function is employed to count the number of times each product ID appears in the `sales` table. The results are then sorted in descending order based on the product count. The `limit 1` clause restricts the output to the top row, effectively identifying the product ID with the highest count.\n\nThe main query then selects the customer ID and the count of the most purchased product for each customer. It filters the `sales` table to include only records where the `product_id` matches the one identified in the CTE, effectively focusing on the most purchased item. Finally, it groups the results by `customer_id` to determine how many times each customer purchased the most popular item.\n\n### 5. Which item was the most popular for each customer?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nwith cte_1 as (\n   select customer_id,\n      product_id,\n      count(product_id) as count_of_item\n   from sales\n   group by customer_id,\n      product_id\n),\ncte_2 as (\n   select *,\n      row_number() over (\n         partition by customer_id\n         order by count_of_item desc\n      ) as order_rank\n   from cte_1\n)\nselect c.customer_id,\n   m.product_name,\n   c.count_of_item\nfrom cte_2 c\n   natural join menu m\nwhere order_rank = 1;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 3 records\n\n|customer_id |product_name | count_of_item|\n|:-----------|:------------|-------------:|\n|C           |ramen        |             3|\n|B           |ramen        |             2|\n|A           |ramen        |             3|\n\n</div>\n:::\n\n\nThis query aims to identify the most popular item for each customer. The query utilizes two common table expressions to process the data and generate the desired output. The first CTE, named `cte_1`, calculates the count of each product purchased by each customer. It groups the rows in the sales table by `customer_id` and `product_id`, and then counts the occurrences of each product ID for each customer. This step determines the frequency of each product purchase for each customer.\n\nThe second CTE, named `cte_2`, assigns a ranking to each product for each customer based on the purchase frequency calculated in `cte_1`. It uses the `row_number()` function and partitions the data by `customer_id`, sorting within each partition by the `count_of_item` in descending order. This step effectively identifies the product with the highest purchase frequency (i.e., the most popular item) for each customer.\n\nThe main query then selects the customer ID, product name, and purchase count for each customer's most popular item. It joins the menu table to obtain the corresponding product names and filters the results to include only records with an `order_rank` of 1, ensuring that only the most popular item for each customer is selected.\n\n### 6. Which item was purchased first by the customer after they became a member?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nwith cte_1 as (\n   select *\n   from members\n      natural join sales\n   order by order_date\n),\ncte_2 as (\n   select customer_id,\n      product_id,\n      order_date,\n      row_number() over(\n         partition by customer_id\n         order by order_date\n      ) as order_rank\n   from cte_1\n   where order_date > join_date\n)\nselect c.customer_id,\n   m.product_name,\n   c.order_date,\n   c.order_rank\nfrom cte_2 c\n   natural join menu m\nwhere order_rank = 1;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 2 records\n\n|customer_id |product_name |order_date | order_rank|\n|:-----------|:------------|:----------|----------:|\n|A           |ramen        |2021-01-10 |          1|\n|B           |sushi        |2021-01-11 |          1|\n\n</div>\n:::\n\n\nThe first CTE, named `cte_1`, combines the `members` and `sales` tables, and sorts the combined data by `order_date`, ensuring a chronological order of transactions. The second CTE, named `cte_2`, focuses on purchases made after each customer's membership start date. It filters the `cte_1` data to include only records where the `order_date` is later than the `join_date` (membership start date).\n\nAdditionally, it assigns an `order_rank` to each purchase for each customer using the `row_number()` function. The ranking is partitioned by `customer_id` and sorted within each partition by `order_date`. This identifies the first purchase (`order_rank` = 1) made by each customer after becoming a member. The main query then selects the customer ID, product name, order date, and order rank for each customer's first purchase after becoming a member. It joins the `menu` table to retrieve the corresponding product names and filters the results to include only records with an `order_rank` of 1, ensuring that only the first purchase is selected.\n\n### 7. Which item was purchased just before the customer became a member?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nwith cte_1 as (\n   select *\n   from members\n      natural join sales\n   order by order_date\n),\ncte_2 as (\n   select customer_id,\n      product_id,\n      join_date,\n      order_date,\n      row_number() over(\n         partition by customer_id\n         order by order_date desc\n      ) as order_rank\n   from cte_1\n   where order_date < join_date\n)\nselect c.customer_id,\n   m.product_name,\n   c.order_date,\n   c.order_rank\nfrom cte_2 c\n   natural join menu m\nwhere order_rank = 1;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 2 records\n\n|customer_id |product_name |order_date | order_rank|\n|:-----------|:------------|:----------|----------:|\n|A           |sushi        |2021-01-01 |          1|\n|B           |sushi        |2021-01-04 |          1|\n\n</div>\n:::\n\n\nThe first CTE, named `cte_1`, combines the members and sales tables, and sorts the combined data by `order_date` in ascending order, ensuring a chronological sequence of transactions.\n\nThe second CTE, `cte_2`, focuses on purchases made before each customer's membership start date. It filters the `cte_1` data to include only records where the `order_date` is earlier than the `join_date` (membership start date).\n\nIt assigns an order_rank to each purchase for each customer using the `row_number()` function. The ranking is partitioned by `customer_id` and sorted within each partition by `order_date` in descending order. This identifies the last purchase (`order_rank` = 1) made by each customer before becoming a member.\n\nThe main query then selects the customer ID, product name, order date, and order rank for each customer's last purchase before becoming a member. It joins the `menu` table to retrieve the corresponding product names and filters the results to include only records with an `order_rank` of 1, ensuring that only the last purchase is selected.\n\n### 8. What is the total items and amount spent for each member before they became a member?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nwith cte_1 as (\n   select *\n   from members\n      natural join sales\n      natural join menu\n   order by order_date\n)\nselect customer_id,\n   count(distinct product_id) as count_of_products,\n   sum(price) as total_amount_spent\nfrom cte_1\nwhere order_date < join_date\ngroup by customer_id;\n\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 2 records\n\n|customer_id | count_of_products| total_amount_spent|\n|:-----------|-----------------:|------------------:|\n|A           |                 2|                 25|\n|B           |                 2|                 40|\n\n</div>\n:::\n\n\nThe query utilizes a CTE named `cte_1` to prepare the data and simplifies the aggregation in the main query.\n\nThe main query then aggregates the data for each customer based on their membership status. It filters the `cte_1` data to include only records where the `order_date` is earlier than the `join_date` (membership start date). For each customer, it counts the distinct `product_id` values to determine the total number of unique items purchased and calculates the sum of price values to determine the total amount spent. The results are grouped by `customer_id` to provide individual summaries for each member.\n\n### 9. If each \\$1 spent equates to 10 points and sushi has a 2x points multiplier - how many points would each customer have?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nwith cte as (\n   select *,\n      case\n         when product_name = 'sushi' then price * 10 * 2\n         else price * 10\n      end points\n   from members\n      natural join sales\n      natural join menu\n)\nselect customer_id,\n   sum(points) as total_points\nfrom cte\ngroup by customer_id;\n\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 2 records\n\n|customer_id | total_points|\n|:-----------|------------:|\n|A           |          860|\n|B           |          940|\n\n</div>\n:::\n\n\nThe CTE combines the `members`, `sales`, and `menu` tables, providing a comprehensive view of customer memberships, their purchases, and the corresponding product names.\n\nThe main query then summarizes the points earned for each customer. It groups the data from the CTE by `customer_id` and calculates the sum of points values for each group, effectively determining the total points earned by each customer.\n\n### 10. In the first week after a customer joins the program (including their join date) they earn 2x points on all items, -- not just sushi - how many points do customer A and B have at the end of January?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nwith cte as (\n   select *,\n      case\n         when product_name = 'sushi' then price * 10 * 2\n         else price * 10\n      end points,\n      case\n         when order_date - join_date <= 7 then 2\n         else 1\n      end multiplier\n   from members\n      natural join sales\n      natural join menu\n),\ncte_2 as (\n   select *,\n      points * multiplier as total_points\n   from cte\n)\nselect customer_id,\n   sum(total_points) as total_points\nfrom cte_2\ngroup by customer_id;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 2 records\n\n|customer_id | total_points|\n|:-----------|------------:|\n|A           |         1720|\n|B           |         1760|\n\n</div>\n:::\n\n\nThe first CTE, named `cte`, joins the `members`, `sales`, and `menu` tables, and calculates the points earned for each purchase using a conditional CASE expression, similar to the previous query.\n\nAdditionally, it assigns a multiplier to each purchase based on whether it falls within the first week after the customer's join date. For purchases within the first week, the multiplier is 2 (double points); for purchases outside the first week, the multiplier is 1 (standard points).\n\nThe second CTE, named `cte_2`, simplifies the calculation by multiplying the points and multiplier columns for each purchase, effectively determining the total points earned per transaction. The main query then summarizes the points earned for each customer, including the double points accrued during the first week. It groups the data from `cte_2` by customer_id and calculates the sum of `total_points` values for each group, providing the total points earned by customer A and customer B at the end of January\n\n### 11. Recreate the following table output using the available data:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nselect s.customer_id,\n    s.order_date,\n    men.product_name,\n    men.price,\n    CASE\n        WHEN s.order_date >= m.join_date THEN 'Y'\n        ELSE 'N'\n    END\nfrom sales s\n    LEFT JOIN menu men ON s.product_id = men.product_id\n    LEFT JOIN members m on m.customer_id = s.customer_id\nORDER BY s.customer_id,\n    s.order_date;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: Displaying records 1 - 10\n\n|customer_id |order_date |product_name | price|case |\n|:-----------|:----------|:------------|-----:|:----|\n|A           |2021-01-01 |sushi        |    10|N    |\n|A           |2021-01-01 |curry        |    15|N    |\n|A           |2021-01-07 |curry        |    15|Y    |\n|A           |2021-01-10 |ramen        |    12|Y    |\n|A           |2021-01-11 |ramen        |    12|Y    |\n|A           |2021-01-11 |ramen        |    12|Y    |\n|B           |2021-01-01 |curry        |    15|N    |\n|B           |2021-01-02 |curry        |    15|N    |\n|B           |2021-01-04 |sushi        |    10|N    |\n|B           |2021-01-11 |sushi        |    10|Y    |\n\n</div>\n:::\n\n\n## Closing the connection\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(con)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}