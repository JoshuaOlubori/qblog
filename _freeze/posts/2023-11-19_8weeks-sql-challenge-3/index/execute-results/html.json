{
  "hash": "e02e1283f30cd8112057ba299660a30a",
  "result": {
    "markdown": "---\ntitle: \"Foodie Fi\"\nsubtitle: \"Third part of a series of SQL case studies\"\nauthor: \"Edun Joshua\"\ndate: \"2023-11-19\"\ncategories: [sql]\nimage: \"image.PNG\"\n---\n\n\n## Introduction\n\nUsing subscription style digital data to answer important business questions.\n\n## Entity Relationship Diagram\n\n![](images/foodie.jpg)\n\n## Database Connection\n\nFirst, I'll create a connection to my local `postgres` database thanks to the **`RPostgres`** package.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# | warning: false\n# Creating a connection to my local postgres database\nlibrary(RPostgres)\ncon <-\n  dbConnect(Postgres(),\n            dbname = \"foodie_fi\",\n            user = \"postgres\",\n            password = my_password)\n```\n:::\n\n\n## Queries\n\n### 1. How many customers has Foodie-Fi ever had?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nSELECT count(DISTINCT customer_id)\nFROM subscriptions;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 1 records\n\n| count|\n|-----:|\n|  1000|\n\n</div>\n:::\n\n\n### 3. What is the monthly distribution of trial plan `start_date` values for our dataset use the start of the month as the group by value?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT upper(to_char(start_date, 'month')) as start_month,\n    count(*) frequency\nfrom subscriptions\nwhere plan_id = 0\ngroup by 1\nORDER BY 2 desc;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: Displaying records 1 - 10\n\n|start_month | frequency|\n|:-----------|---------:|\n|MARCH       |        94|\n|JULY        |        89|\n|AUGUST      |        88|\n|MAY         |        88|\n|JANUARY     |        88|\n|SEPTEMBER   |        87|\n|DECEMBER    |        84|\n|APRIL       |        81|\n|JUNE        |        79|\n|OCTOBER     |        79|\n\n</div>\n:::\n\n\n### 3. What plan `start_date` values occur after the year 2020 for our dataset? Show the breakdown by count of events for each `plan_name` ?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nSELECT p.plan_name,\n    count(*) as count_of_events_after_2020\nfrom subscriptions s\n    natural join plans p\nwhere EXTRACT(\n        year\n        from start_date\n    ) > 2020\ngroup by 1;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 4 records\n\n|plan_name     | count_of_events_after_2020|\n|:-------------|--------------------------:|\n|pro annual    |                         63|\n|churn         |                         71|\n|pro monthly   |                         60|\n|basic monthly |                          8|\n\n</div>\n:::\n\n\n### 4. What is the customer count and percentage of customers who have churned rounded to 1 decimal place?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nwith cte1 as (\n    select 1 as id,\n        count(customer_id)::numeric as whole\n    from subscriptions\n),\ncte2 as (\n    select 1 as id,\n        count(customer_id)::numeric as part\n    from subscriptions\n    where plan_id = 4\n)\nSELECT cte1.whole as total_customers,\n    round(cte2.part / cte1.whole, 2) * 100 as pct_churned\nfrom cte1\n    natural join cte2;\n\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 1 records\n\n| total_customers| pct_churned|\n|---------------:|-----------:|\n|            2650|          12|\n\n</div>\n:::\n\n\n### 5. How many customers have churned straight after their initial free trial? what percentage is this rounded to the nearest whole number?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nwith cte as (\n    -- using the lead window function to find the\n    -- preceding row to a particular row\n    select *,\n        lead(plan_id) over(partition by customer_id) as lead_plan_id\n    from subscriptions\n    order by customer_id,\n        plan_id\n),\ncte2 as (\n    -- getting rows whose values satisfy the condition in the question\n    select *\n    from cte\n    where plan_id = 0\n        and lead_plan_id = 4\n) -- solution\nselect count(*) as count_of_customers_who_churned_after_free_trial\nfrom cte2 \n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 1 records\n\n| count_of_customers_who_churned_after_free_trial|\n|-----------------------------------------------:|\n|                                              92|\n\n</div>\n:::\n\n\n### 6. What is the number and percentage of customer plans after their initial free trial?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nwith cte1 as (\n    select 1 as id,\n        count(customer_id)::numeric as whole\n    from subscriptions\n),\ncte2 as (\n    select 1 as id,\n        count(customer_id)::numeric as part\n    from subscriptions\n    where plan_id <> 0\n)\nSELECT cte2.part as customer_count_after_trial_plan,\n    round(cte2.part / cte1.whole, 2) * 100 as pct_ccatp\nfrom cte1\n    natural join cte2;\n\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 1 records\n\n| customer_count_after_trial_plan| pct_ccatp|\n|-------------------------------:|---------:|\n|                            1650|        62|\n\n</div>\n:::\n\n\n### 7. How many customers have upgraded to an annual plan in 2020?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nwith cte1 as (\n    -- using the lead window function to find the\n    -- preceding row to a particular row\n    select *,\n        lead(plan_id) over(partition by customer_id) as lead_plan_id\n    from subscriptions\n    order by customer_id,\n        plan_id\n),\n-- filtering to only annual plans\ncte2 as (\n    select *,\n        lead_plan_id - plan_id as diff\n    from cte1\n    where lead_plan_id = 3\n) -- excluding churned customers and unupgraded plans\nselect count(DISTINCT customer_id) as upgraded_customers_2020_count\nfrom cte2\nwhere (diff > 0)\n    and (lead_plan_id <> 4)\n    and EXTRACT(\n        year\n        from start_date\n    ) = 2020;\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 1 records\n\n| upgraded_customers_2020_count|\n|-----------------------------:|\n|                           253|\n\n</div>\n:::\n\n\n### 8. How many days on average does it take for a customer to upgrade to an annual plan from the -- day they join Foodie-Fi?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nwith cte1 as (\n    select *,\n        max(plan_id) over (partition by customer_id) as highest_plan_suscribed,\n        max(start_date) over (partition by customer_id) as date_of_hps,\n        min(start_date) over (partition by customer_id) as date_of_lps,\n        row_number() over (partition by customer_id) as sn\n    from subscriptions\n    order by customer_id,\n        start_date,\n        plan_id\n),\ncte2 as(\n    select *,\n        date_of_hps - date_of_lps as diff_in_days\n    from cte1\n    where highest_plan_suscribed = 3\n        and sn = 1\n)\nselect round(avg(diff_in_days)::numeric, 2) as avg_days_to_upgrade_to_annual\nfrom cte2\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 1 records\n\n| avg_days_to_upgrade_to_annual|\n|-----------------------------:|\n|                        105.95|\n\n</div>\n:::\n\n\n### 9. How many customers downgraded from a pro monthly to a basic monthly plan in 2020?\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nwith cte1 as(\n        select *,\n            lead(plan_id) over(partition by customer_id) as lead_plan_id\n        from subscriptions\n        order by customer_id,\n            start_date,\n            plan_id\n    ),\n    cte2 as (\n        select customer_id,\n            plan_id,\n            lead_plan_id,\n            start_date\n            from cte1\n        where plan_id = 2\n            and lead_plan_id = 1\n            and EXTRACT(\n                year\n                from start_date\n            ) = 2020\n    )\nselect count(*) as number_of_customers_downgrade_from_prom_basm\nfrom cte2\n\n```\n\n\n<div class=\"knitsql-table\">\n\n\nTable: 1 records\n\n| number_of_customers_downgrade_from_prom_basm|\n|--------------------------------------------:|\n|                                            0|\n\n</div>\n:::\n\n\n## Closing the connection\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(con)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}